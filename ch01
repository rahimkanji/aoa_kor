This chapter is a “quick-start” chapter 
that lets you start writing basic assembly 
language programs as rapidly as possible. 
This chapter does the following:
z Presents the basic syntax of an HLA (High Level Assembly) program
z Introduces you to the Intel CPU architecture
z Provides a handful of data declarations, machine instructions, and highlevel control statements 
z Describes some utility routines you can call in the HLA Standard Library
z Shows you how to write some simple assembly language programs
By the conclusion of this chapter, you should understand the basic 
syntax of an HLA program and should understand the prerequisites that are 
needed to start learning new assembly language features in the chapters that 
follow.

이번장은 여러분이 최대한 빨리 기본적인 어셈블리 프로그램을 만들수 있도록
다음과 같은 내용을 다루겠습니다.
- HLA 프로그램의 기본적인 문법을 보여주고
- 인텔 CPU 아키텍쳐를 소개하고
- 쉽게 쓸 수 있는 데이터 선언과 어셈블리 명령어, 고급 제어문을 알려주고
- HLA 표준 라이브러리에 있는 몇가지 쓸만한 루틴을 설명하고
- 어떻게하면 기본적인 어셈블리 언어 프로그램을 작성할 수 있는지 보여줍니다.

이번 장을 읽으면 HLA 프로그램의 기본 문법을 이해하게되고,
나머지 장들에 사용되는 어셈블리 언어의 특징들을 이해하는데 필요한 기본 지식들을 얻게됩니다.

A typical HLA program takes the form shown in Figure 1-1.
pgmID in the template above is a user-defined program identifier. You 
must pick an appropriate descriptive name for your program. In particular, 
pgmID would be a horrible choice for any real program. If you are writing 
programs as part of a course assignment, your instructor will probably give 
you the name to use for your main program. If you are writing your own HLA 
program, you will have to choose an appropriate name for your project.
Identifiers in HLA are very similar to identifiers in most high-level 
languages. HLA identifiers may begin with an underscore or an alphabetic 
character and may be followed by zero or more alphanumeric or underscore 
characters. HLA’s identifiers are case neutral. This means that the identifiers 
are case sensitive insofar as you must always spell an identifier exactly the same 
way in your program (even with respect to upper- and lowercase). However, 
unlike in case-sensitive languages such as C/C++, you may not declare two 
identifiers in the program whose name differs only by alphabetic case.
A traditional first program people write, popularized by Kernighan and 
Ritchie’s The C Programming Language, is the “Hello, world!” program. This 
program makes an excellent concrete example for someone who is learning 
a new language. Listing 1-1 presents the HLA helloWorld program.

일반적인 HLA 프로그램은 그림 1-1과 같은 형태를 가집니다.
그림1-1
위의 형태에서 pgmID는 사용자가 정의한 식별자입니다. 당신의 프로그램을 잘 설명할 수 있는 이름을 식별자로 정해야합니다.
이름을 잘못지으면 프로그램을 끔찍하게 만들 수 있습니다. 수업 과제로 프로그램을 만들 때는
메인 프로그램의 이름을 교수님이 정해줄 것입니다. 혼자서 HLA 프로그램을 만들 때는 스스로 프로젝트의
성격에 맞는 이름을 지어야합니다. 이런 식별자들은 다른 대부분의 고급 언어들과 마찬가지로 시작글자는 밑줄이나 알파벳으로
해야하고 나머지 글자는 숫자나 알파벳, 밑줄을 사용할 수 있습니다. HLA의 식별자는 대소문자를 구분하지 않습니다.
프로그램 안에 정의된 식별자는 각 글자가 대문자,소문자 구분없이 동일한 이름을 가져야합니다. C/C++같은 대소문자를 구별하는
언어들과 다르게 대소문자만 다르고 같은 이름인 식별자 이름을 사용할 수 없습니다.
Kernighan과 Ritchie의 The C Programming Language 책에서 유명해지고 많음 사람들이 
자신의 첫 프로그램으로 만들어온 "Hello, world!" 프로그램을 만들어보겠습니다.
이 프로그램은 새로운 언어를 배우는 사람들에게 좋은 예제가 되어왔습니다. 코드1-1은 HLA용 helloWorld 프로그램입니다.

program helloWorld;
#include( "stdlib.hhf" );
begin helloWorld;
 stdout.put( "Hello, World of Assembly Language", nl );
end helloWorld;

The #include statement in this program tells the HLA compiler to 
include a set of declarations from the stdlib.hhf (standard library, HLA 
Header File). Among other things, this file contains the declaration of the 
stdout.put code that this program uses. 

#include는 HLA 컴파일러에게 이 프로그램이 stdlib.hhf(표준 라이브러리, HLA Header File의 약자)의 선언들을
포함할 것이라고 알려줍니다. 이 파일에는 우리가 사용할 stdout.put 코드의 선언이 들어있습니다.


The stdout.put statement is the print statement for the HLA language. 
You use it to write data to the standard output device (generally the console). 
To anyone familiar with I/O statements in a high-level language, it should 
be obvious that this statement prints the phrase Hello, World of Assembly 
Language. The nl appearing at the end of this statement is a constant, also 
defined in stdlib.hhf, that corresponds to the newline sequence.

stdout.put은 HLA언어에서 표준 출력 장치(일반적으로 콘솔)에 데이터를 출력하는데 사용됩니다.
고급언어의 입출력문에 익숙하다면 stdout.put이 어셈블리 언어에서 Hello, World를 출력하는
부분이라는 것을 금방 알 수 있습니다. 끝에있는 nl은 상수인데 stdlib.hhf에 정의되어있고, 
고급언어의 개행문자에 해당합니다.


Note that semicolons follow the program, begin, stdout.put, and end
statements. Technically speaking, a semicolon does not follow the #include
statement. It is possible to create include files that generate an error if a 
semicolon follows the #include statement, so you may want to get in the 
habit of not putting a semicolon here.

program, begin, stdout.put, end 문을 보면 끝에 세미콜론이 있는 것을 알 수 있습니다.
그런데 사실 문법적으로 정확하게 말하면 #include문 끝에 있는 세미콜론은 #include문을 위해
있는 것이 아닙니다. #include문의 끝에 세미콜론이 있으면 에러를 내도록 #include문에 들어갈 파일을 만들어서
세미콜론을 쓰지 않을 수도 있습니다.

The #include is your first introduction to HLA declarations. The #include
itself isn’t actually a declaration, but it does tell the HLA compiler to 
substitute the file stdlib.hhf in place of the #include directive, thus inserting 
several declarations at this point in your program. Most HLA programs you 
will write will need to include one or more of the HLA Standard Library 
header files (stdlib.hhf actually includes all the standard library definitions 
into your program).

이 #include가 HLA언어에서 여러분이 배우시게될 첫번째 선언문입니다. #include 자체는 사실 선언문이 아닙니다.
단지 HLA 컴파일러에게 stdlib.hhf 파일을 #include 지시어가 있는 부분에 집어넣으라고
알려주는 일을 할뿐입니다. 그래서 결과적으로 프로그램에 stdlib.hhf에있는 여러가지 선언들이 추가되는 것입니다.
우리가 만들 대부분의 HLA 프로그램들은 하나 이상 HLA 표준 라이브러리의 헤더 파일을 포함할 것입니다(stdlib.hhf는
거의 모든 표준 라이브러리 정의들을 포함하고 있습니다).


Compiling this program produces a console application. Running this 
program in a command window prints the specified string, and then control 
returns to the command-line interpreter (or shell in Unix terminology).
HLA is a free-format language. Therefore, you may split statements 
across multiple lines if this helps to make your programs more readable. For 
example, you could write the stdout.put statement in the helloWorld program 
as follows:

이 프로그램을 컴파일하면 콘솔용 어플리케이션이 만들어집니다. 만들어진 어플리케이션을
윈도우의 커맨트 창에서 실행하면 문자열이 출력되고 다시 커맨드라인 인터프리터(유닉스의 쉘과 같은)가 나타납니다.
HLA는 형식이 자유로운 언어입니다. 그렇게 해서 프로그램이 더 잘 읽혀질 수만 있다면 하나의 문장을 여러 줄에
써도 됩니다. helloWorld 프로그램의 stdout.put 문장을 다음과 같이 써도 되는 것입니다.

stdout.put
(
"Hello, "
"World of Assembly Language",
nl
);

Indeed, nl (the newline) is really nothing more than a string constant,
so (technically) the comma between the nl and the preceding string isn’t
necessary. You’ll often see the above written as
stdout.put( "Hello, World of Assembly Language" nl );
Notice the lack of a comma between the string constant and nl; this turns
out to be legal in HLA, though it applies only to certain constants; you may
not, in general, drop the comma. Chapter 4 explains in detail how this
works. This discussion appears here because you’ll probably see this “trick”
employed by sample code prior to the formal explanation.

실제로 nl(개행문자)는 단순히 문자열 상수일 뿐이라서 (기술적으로만 따지면) nl과
그 앞의 문자열 사이의 콤마는 없어도 됩니다. 앞으로 stdout.put( "Hello, World of Assembly Language" nl ); 와 같이
쓰는 것을 자주 보게 될 것입니다. 일반적으로는 콤마를 빠뜨리면 안됩니다. 일부 상수들만 콤마를 생략해서
사용할 수 있으므로 주의해야합니다. 4장에서 세부적인 동작 원리를 설명하겠습니다. 여기에서는
이런 트릭이 있다는 것만 알아두시기 바랍니다.

1.2 Running Your First HLA Program
The whole purpose of the “Hello, world!” program is to provide a simple
example by which someone who is learning a new programming language
can figure out how to use the tools needed to compile and run programs in
that language. True, the helloWorld program in Section 1.1 helps demonstrate
the format and syntax of a simple HLA program, but the real purpose behind
a program like helloWorld is to learn how to create and run a program from
beginning to end. Although the previous section presents the layout of an
HLA program, it did not discuss how to edit, compile, and run that program.
This section will briefly cover those details.

1.2 첫번째 HLA 프로그램을 실행해보기

"Hello, world!" 프로그램은 새로운 프로그래밍 언어를 배우는 사람에게 그 언어로된 프로그램의 컴파일과 실행에
어떤 도구들이 사용되는지를 보여주는게 진짜 목적입니다. 1.1장에있는 helloWorld 프로그램를 통해
간단한 HLA 프로그램의 문법과 형태를 알 수 있는 것도 사실입니다. 하지만 진짜 목적은
프로그램을 생성하고 실행하는 방법을 전체적으로 배우는 것입니다. 이전 장에서 HLA 프로그램의
구성을 보긴 했지만 어떻게 편집하고 컴파일하고 프로그램을 실행하는지는 설명하지 않았습니다.
이번 장에서 그것들을 다루겠습니다.


All of the software you need to compile and run HLA programs can be
found at http://www.artofasm.com/ or at http://webster.cs.ucr.edu/. Select High
Level Assembly from the Quick Navigation Panel and then the Download
HLA link from that page. HLA is currently available for Windows, Mac OS X,
Linux, and FreeBSD. Download the appropriate version of the HLA software
for your system. From the Download HLA web page, you will also be able
to download all the software associated with this book. If the HLA download
doesn’t include them, you will probably want to download the HLA
reference manual and the HLA Standard Library reference manual along
with HLA and the software for this book. This text does not describe the
entire HLA language, nor does it describe the entire HLA Standard Library.
You’ll want to have these reference manuals handy as you learn assembly
language using HLA.

HLA 프로그램을 컴파일하고 실행하기 위해 필요한 모든 소프트웨어는 
http://www.artofasm.com/ or at http://webster.cs.ucr.edu/ 에서 찾을 수 있습니다.
High Level Assembly 메뉴를 선택하고 HLA 다운로드 링크를 클릭하면 됩니다. HLA는 현재
윈도우, Mac OS X, 리눅스, FreeBSD에서 사용가능합니다. HLA 다운로드 관련 웹 페이지에서
이 책과 관련된 모든 소프트웨어를 다운받을 수 있습니다. HLA의 레퍼런스 메뉴얼이나
HLA 표준 라이브러리 레퍼런스 메뉴얼도 다운받는게 좋을 것입니다. 이 책에서
HLA 언어의 전부를 설명하지 않고 HLA 표준 라이브러리도 전부를 설명하지 않을 것이므로
이런 레퍼런스 메뉴얼이 필요하게 될겁니다.


This section will not describe how to install and set up the HLA system
because those instructions change over time. The HLA download page for
each of the operating systems describes how to install and use HLA. Please
consult those instructions for the exact installation procedure.
Creating, compiling, and running an HLA program is very similar to the
process you’d use when creating, compiling, or running a program in any
computer language. First, because HLA is not an integrated development
environment (IDE) that allows you to edit, compile, test and debug, and run
your application all from within the same program, you’ll create and edit
HLA programs using a text editor.

이번 장에서 HLA 시스템을 설치하고 환경을 설정하는 방법을 설명하지 않을 것입니다. 그런 것들은
항상 변하기 때문입니다. HLA 다운로드 페이지에 각 운영체제별로 HLA를 설치하고 사용하는
방법에 대해서 나와있습니다. 정확한 설치를 위해 자세히 살펴보시기 바랍니다.
HLA 프로그램을 만들고 컴파일하고 실행하는 것은 다른 어떤 언어의 프로그램과도 동일합니다.
HLA용 통합 개발 환경(IDE)가 없기 때문에 하나의 프로그램 안에서 편집, 컴파일, 테스트, 디버깅,
어플리케이션의 실행 등을 한꺼번에 할 수는 없습니다. 처음에는 텍스트 에디터를 이용해서
HLA 프로그램을 생성하고 편집해야합니다.

Windows, Mac OS X, Linux, and FreeBSD offer many text editor options.
You can even use the text editor provided with other IDEs to create and edit
HLA programs (such as those found in Visual C++, Borland’s Delphi, Apple’s
Xcode, and similar languages). The only restriction is that HLA expects
ASCII text files, so the editor you use must be capable of manipulating and
saving text files. Under Windows you can always use Notepad to create HLA
programs. If you’re working under Linux and FreeBSD you can use joe, vi, or
emacs. Under Mac OS X you can use XCode or Text Wrangler or another
editor of your preference.

윈도우나 맥, 리눅스, FreeBSD 모두 다양한 에디터를 제공하고 있습니다. 다른 언어의 IDE(Visual C++, 볼랜드 델파이,
애플의 Xcode 등)를 이용해서 HLA 프로그램을 편집할 수도 있습니다. HLA은 아스키 텍스트 파일만 인식하므로
텍스트 파일을 만들고 저장할 수만 있으면 됩니다. 윈도우에서는 메모장을 사용할 수도 있습니다. 맥에서는
XCode나 Text Wrangler 등 좋아하는 것을 사용하시면 됩니다.

The HLA compiler2 is a traditional command-line compiler, which means
that you need to run it from a Windows command-line prompt or a Linux/
FreeBSD/Mac OS X shell. To do so, enter something like the following into
the command-line prompt or shell window:
hla hw.hla
This command tells HLA to compile the hw.hla (helloWorld) program to
an executable file. Assuming there are no errors, you can run the resulting
program by typing the following command into your command prompt
window (Windows):
hw
or into the shell interpreter window (Linux/FreeBSD/Mac OS X):
./hw
If you’re having problems getting the program to compile and run
properly, please see the HLA installation instructions on the HLA download
page. These instructions describe in great detail how to install, set up,
and use HLA.

HLA 컴파일러는 커맨드 라인 컴파일러입니다. 윈도우에서는 커맨드 라인 프롬프트에서 실행하시고,
리눅스나 FreeBSD, 맥에서는 쉘에서 실행하시면 됩니다. 다음과 같이 커맨드 라인 프롬프트나
쉘에서 입력하시기 바랍니다.

hla hw.hla

이렇게 입력하면 HLA 컴파일러가 hw.hla (helloWorld) 프로그램을 컴파일하고 실행 파일을 만들어냅니다.
컴파일하면서 에러만 발생하지 않았다면 다음과 같이 입력해서 프로그램을 실행할 수 있습니다.
윈도우의 커맨드 프롬프트는

hw

이고 쉘 인터프리터에서는 (리눅스/FreeBSD/맥)

./hw

를 입력하면 됩니다.
컴파일이나 실행을 하실 수 없다면 HLA 다운로드 페이지에 있는 HLA 설치 안내를 확인하시기 바랍니다.
HLA의 설치와 환경 설정, 사용법에 대해 자세한 설명이 있습니다.


1.3 Some Basic HLA Data Declarations
HLA provides a wide variety of constant, type, and data declaration statements.
Later chapters will cover the declaration sections in more detail,
but it’s important to know how to declare a few simple variables in an HLA
program.
HLA predefines several different signed integer types including int8,
int16, and int32, corresponding to 8-bit (1-byte) signed integers, 16-bit
(2-byte) signed integers, and 32-bit (4-byte) signed integers, respectively.3
Typical variable declarations occur in the HLA static variable section. A
typical set of variable declarations takes the form shown in Figure 1-2.

1.3 HLA의 기본 데이터에 대한 설명

HLA는 다양한 상수와 타입, 데이터 선언들이 있습니다. 다음에 데이터 선언 섹션에 대해 자세히 설명하겠지만,
간단한 변수들을 선언하는 방법을 먼저 배우도록 하겠습니다.
HLA는 8비트(1바이트), 16비트(2바이트), 32비트(4바이트) 크기의 부호있는 정수를 
int8, int16, int32 와 같은 타입을 몇가지 미리 정의해놓았습니다. 일반적인 변수 선언은 그림 1-2와 같이 합니다.

i8, i16, and i32
are the names of
the variables to
declare here.

static is the keyword that begins
the variable declaration section.
static
i8: int8;
i16: int16;
i32: int32;
int8, int16, and int32 are the names
of the data types for each declaration.

i8, i16, i32는 여기 선언된 변수들의 이름입니다.
static은 변수 선언을 위한 섹션이 시작되는걸 표시하는 키워드입니다.
int8, int16, int32는 선언문들의 데이터 타입입니다.

Those who are familiar with the Pascal language should be comfortable
with this declaration syntax. This example demonstrates how to declare
three separate integers: i8, i16, and i32. Of course, in a real program you
should use variable names that are more descriptive. While names like i8
and i32 describe the type of the object, they do not describe its purpose.
Variable names should describe the purpose of the object.
In the static declaration section, you can also give a variable an initial
value that the operating system will assign to the variable when it loads the
program into memory. Figure 1-3 provides the syntax for this.

파스칼 언어에 익숙하신 분들은 이런 선언문이 편하게 느껴지실 겁니다. 이 예제는 세가지 정수형(
i8, i16, i32)을 선언하는 방법을 보여줍니다. 물론 실제 프로그램에서는 좀더 의미있는 이름을
사용하셔야합니다. i8이나 i32같은 이름은 각 객체의 타입은 나타낼 수 있지만 어떤 목적으로 사용되는
객체인지를 알 수 없습니다. static 선언 섹션에서 운영체제가 프로그램을 메모리로 로드할 때
각 변수가 어떤 초기값을 가지게될지를 지정할 수 있습니다. 그림 1-3은 그러기위한 문법을 보여줍니다.

The constant assignment
operator, :=, tells HLA
that you wish to initialize
the specified variable
with an initial value.

상수를 할당 연산자는 := 인데 해당 변수에 초기 값을 설정하는 연산자입니다.

static
i8: int8 := 8;
i16: int16 := 1600;
i32: int32 := -320000;
The operand after the
constant assignment
operator must be a
constant whose type
is compatible with the
variable you are
initializing.

상수 할당 연산자 뒤에 나오는 상수는 할당되는 변수의 타입과 맞는 것이어야 합니다.

It is important to realize that the expression following the assignment
operator (:=) must be a constant expression. You cannot assign the values of
other variables within a static variable declaration.
Those familiar with other high-level languages (especially Pascal) should
note that you can declare only one variable per statement. That is, HLA does
not allow a comma-delimited list of variable names followed by a colon and a
type identifier. Each variable declaration consists of a single identifier, a
colon, a type ID, and a semicolon.
Listing 1-2 provides a simple HLA program that demonstrates the use of
variables within an HLA program.

할당 연산자(:=) 다음에 나오는 표현식은 반드시 상수 표현식이어야 합니다. 상수 변수의 선언에
다른 변수의 값을 할당할 수는 없습니다. 다른 고급 언어(파스칼등)에서와 같이 하나의 선언문에는
하나의 변수만 선언되야 합니다. HLA 선언문에서 콜론과 타입 표시 다음에 변수들의 이름을
콤마를붙여 여러개 쓰는 형식은 허용되지 않습니다. 각 변수 선언은 하나의 변수 이름과
콜론, 타입, 세미콜론으로 이루어져야합니다.
코드1-3는 HLA 프로그램에서 어떻게 변수를 사용하는지에 대한 간단한 예제입니다.

In addition to static variable declarations, this example introduces three
new concepts. First, the stdout.put statement allows multiple parameters. If
you specify an integer value, stdout.put will convert that value to its string
representation on output.
The second new feature introduced in Listing 1-2 is the stdin.get
statement. This statement reads a value from the standard input device
(usually the keyboard), converts the value to an integer, and stores the
integer value into the NotInitialized variable. Finally, Listing 1-2 also
introduces the syntax for (one form of) HLA comments. The HLA compiler
ignores all text from the // sequence to the end of the current line. (Those
familiar with Java, C++, and Delphi should recognize these comments.)

이 예제에는 정적 변수 선언과함께 새로운 개념 3개가 있습니다. 첫번째로
stdout.put 문장은 여러개의 파라미터를 가질 수 있습니다. 정수값을
파라미터로 사용하면 stdout.put이 문자열로 변환해서 출력해줍니다.
코드1-3에서 두번째로 알게되는 새로운 기능은 stdin.get 문장입니다. 이 문장은 표준 입력 장치에서
값을 읽어서 정수로 변환한 후 NotInitialized 변수에 저장합니다. 마지막으로
코드 1-2에서 주석을 작성하는 방법중 한가지를 보게됩니다. HLA 컴파일러는
각 줄에서 // 다음에 어떤 내용이 있던 무시합니다. (자바, C++, 델파이 등이 동일한
주석 표시를 씁니다.)

1.4 Boolean Values
HLA and the HLA Standard Library provide limited support for boolean
objects. You can declare boolean variables, use boolean literal constants,
use boolean variables in boolean expressions, and you can print the values
of boolean variables.
Boolean literal constants consist of the two predefined identifiers true
and false. Internally, HLA represents the value true using the numeric value 1;
HLA represents false using the value 0. Most programs treat 0 as false and
anything else as true, so HLA’s representations for true and false should
prove sufficient.
To declare a boolean variable, you use the boolean data type. HLA uses
a single byte (the least amount of memory it can allocate) to represent
boolean values. The following example demonstrates some typical
declarations:

1.4 부울 변수
HLA과 HLA 표준 라이브러리로 부울 객체를 사용할 수 있습니다. 부울 변수를 선언할 수 있고,
부울값을 표현하는 문자 상수와 부울 변수를 사용하여 부울 표현식을 사용할 수 있습니다.
그리고 부울 변수의 값을 출력할 수도 있습니다.
부울 문자 상수는 true와 false 라는 이름으로 미리 정의된 상수입니다. HLA은 내부적으로
숫자 1을 참으로 표현하고, 0으로 거짓값을 표현합니다. 대부분의 프로그램들이
0을 거짓으로 처리하고 다른 값들을 참으로 표현하므로 HLA이 참과 거짓을 표현하는데
왜 그런 값을 사용하는지 알 수 있습니다.
부울 데이터 타입을 사용하면 부울 변수를 선언할 수 있습니다. HLA은 부울 값을 표현하는데
1바이트 (할당할 수 있는 최소한의 메모리 크기)를 사용합니다. 다음 예제에서
몇가지 전형적인 선언문을 볼 수 있습니다.

static
BoolVar: boolean;
HasClass: boolean := false;
IsClear: boolean := true;

As this example demonstrates, you can initialize boolean variables if you
desire.
Because boolean variables are byte objects, you can manipulate them
using any instructions that operate directly on 8-bit values. Furthermore, as
long as you ensure that your boolean variables only contain 0 and 1 (for
false and true, respectively), you can use the 80x86 and, or, xor, and not
instructions to manipulate these boolean values (these instructions are
covered in Chapter 2).

위의 예제처럼 부울 변수를 초기화할 수 있습니다. 부울 변수가 1바이트 객체이기 때문에
8비트 값을 취급하는 어떤 연산자든지 이용할 수 있습니다. 또한 부울 변수가
0 아니면 1(거짓과 참) 값만 가지고 있기 때문에 80x86의 and, or, xor, not 명령어
(이 명령어들은 2장에서 다룹니다)를 사용해서 부울 값들을 조작할 수 있습니다.

You can print boolean values by making a call to the stdout.put routine.
For example:

부울 변수는 다음 예제와 같이 stdout.put 루틴을 이용해서 출력할 수 있습니다.

stdout.put( BoolVar )

This routine prints the text true or false depending upon the value of
the boolean parameter (0 is false; anything else is true). Note that the HLA
Standard Library does not allow you to read boolean values via stdin.get.

파라미터의 부울 값에 따라(0은 false, 그 외에는 true) true나 false 라고 출력해줍니다. HLA 표준 라이브러리에서
stdin.get으로 부울 값을 읽을 수 없다는 것에 주의하시기 바랍니다.

1.5 Character Values
HLA lets you declare 1-byte ASCII character objects using the char data type.
You may initialize character variables with a literal character value by
surrounding the character with a pair of apostrophes. The following example
demonstrates how to declare and initialize character variables in HLA:

1.5 문자 값

HLA에서 1바이트 아스키 문자는 char 데이터 타입으로 선언됩니다. 문자 값은
작은 따옴표 '를 문자 앞뒤로 써서 표현하고 문자 변수의 초기화 값으로 쓸 수 있습니다. 다음 예제를 보면
HLA에서 문자 변수를 선언하고 초기화하는 방법을 알 수 있습니다.

static
c: char;
LetterA: char := 'A';

You can print character variables use the stdout.put routine, and you can
read character variables using the stdin.get procedure call.

문자 변수를 출력할 때는 stdout.put 루틴을 사용하고, 문자 변수로 값을 읽을 때는
stdin.get을 호출하시기 바랍니다.

1.6 An Introduction to the Intel 80x86 CPU Family
Thus far, you’ve seen a couple of HLA programs that will actually compile
and run. However, all the statements appearing in programs to this point
have been either data declarations or calls to HLA Standard Library routines.
There hasn’t been any real assembly language. Before we can progress any
further and learn some real assembly language, a detour is necessary; unless
you understand the basic structure of the Intel 80x86 CPU family, the
machine instructions will make little sense.

1.6 Intel 80x86 CPU 계열 소개

The Intel CPU family is generally classified as a Von Neumann Architecture
Machine. Von Neumann computer systems contain three main building blocks:
the central processing unit (CPU), memory, and input/output (I/0) devices. These
three components are interconnected using the system bus (consisting of the
address, data, and control buses). The block diagram in Figure 1-4 shows this
relationship.

인텔 CPU 계열는 일반적으로 폰 노이만 구조로 분류됩니다. 폰 노이만 컴퓨터 시스템은
크게 3개의 블록(중앙 처리 장치(CPU), 메모리, 입출력(I/O) 장치)으로 이루어집니다.  이 세가지
요소는 시스템 버스(주소값,데이터, 제어 버스로 이루어지는)로 연결됩니다. 그림 1-4의
블록 다이어그램을 보면 그것들의 연결 모습을 알 수 있습니다.

The CPU communicates with memory and I/O devices by placing a
numeric value on the address bus to select one of the memory locations or
I/O device port locations, each of which has a unique binary numeric address.
Then the CPU, memory, and I/O devices pass data among themselves by
placing the data on the data bus. The control bus contains signals that
determine the direction of the data transfer (to/from memory and to/from
an I/O device).

CPU는 메모리나 I/O 장치 들과 통신하기 위해 주소 버스에 숫자 값을 전송합니다.
메모리나 입출력 장치의 포트는 고유한 번호를 가지고 있어서
주소 버스의 값에 따라 메모리의 특정 지역을 선택하거나 입출력 장치의 포트를 선택할 수 있습니다.
그런 후 CPU와 메모리, 입출력 장치들은 데이터 버스에 데이터를 전송해서 서로 간에 데이터를 주고 받습니다.
제어 버스는 데이터의 전송 방향(메모리로부터 입출력 장치로, 아니면 입출력 장치로부터 메모리로)을 결정하는 신호를
가지고 있습니다.


The 80x86 CPU registers can be broken down into four categories: 
general-purpose registers, special-purpose application-accessible registers, 
segment registers, and special-purpose kernel-mode registers. Because 
the segment registers aren’t used much in modern 32-bit operating systems 
(such as Windows, Mac OS X, FreeBSD, and Linux) and because this text is 
geared to writing programs written for 32-bit operating systems, there is little 
need to discuss the segment registers. The special-purpose kernel-mode registers 
are intended for writing operating systems, debuggers, and other systemlevel tools. 
Such software construction is well beyond the scope of this text. 
The 80x86 (Intel family) CPUs provide several general-purpose registers 
for application use. These include eight 32-bit registers that have the 
following names: EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP.
The E prefix on each name stands for extended. This prefix differentiates the 32-bit 
registers from the eight 16-bit registers that have the 
following names: AX, BX, CX, DX, SI, DI, BP, and SP.

80x86 CPU의 레지스터는 4가지로 종류로 나눌 수 있습니다. 범용 레지스터와
어플리케이션도 접근가능한 특수 레지스터, 세그먼트 레지스터, 커널 모드에서만
접근할 수 있는 특수 레지스터입니다. 세그먼트 레지스터는 최신 32비트 운영체제(윈도우,
맥, FreeBSD, 리눅스 등)에서 잘 사용되지 않고, 또 우리는 32비트 운영체제에서 동작할
프로그램을 만들 계획이므로 세그먼트 레지스터는 설명하지 않겠습니다. 커널 모드용 특수 레지스터는
운영체제나 디버거 등의 시스템레벨 툴을 구현할 때 사용됩니다. 그런 소프트웨어 개발은
이 책의 범위 밖입니다. 80x86(인텔 계열) CPU는 어플리케이션에서 사용할 수 있도록 여러 개의
범용 레지스터를 가지고 있습니다. 8개의 범용 레지스터의 이름은 각각: EAX,
EBX, ECX, EDX, ESI, EDI, EBP, ESP 입니다. 각 이름에 붙은 E는 확장을 의미합니다.
16비트 레지스터의 이름이 AX,BX,CX,DX,SI,DI,BP,SP 인데 여기에서 확장되어서
32비트가 되었다는 의미입니다.


Finally, the 80x86 CPUs provide eight 8-bit registers that have the 
following names: AL, AH, BL, BH, CL, CH, DL, and DH.
Unfortunately, these are not all separate registers. That is, the 80x86 
does not provide 24 independent registers. Instead, the 80x86 overlays the 
32-bit registers with the 16-bit registers, and it overlays the 16-bit registers 
with the 8-bit registers. Figure 1-5 shows this relationship. 
The most important thing to note about the general-purpose registers is 
that they are not independent. Modifying one register may modify as many as 
three other registers. For example, modification of the EAX register may very 
well modify the AL, AH, and AX registers. This fact cannot be overemphasized 
here. A very common mistake in programs written by beginning assembly 
language programmers is register value corruption because the programmer 
did not completely understand the ramifications of the relationship shown in 
Figure 1-5. 

80x86 CPU는 AL, AH, BL, BH, CL, CH, DL, DH 총 8개의 8비트 레지스터를 가지고 있습니다.
불행히도 이것들이 전부 개별적인 레지스터는 아닙니다. 80x86이 총 24개의 독립적인
레지스터를 가지고 있는 것이 아닙니다. 대신 16비트 레지스터가 합쳐져서 32비트 레지스터가 되고,
8비트 레지스터가 합쳐져서 16비트 레지스터가 됩니다. 범용 레지스터에 대해 가장 알아두셔야
할 사실이 지금까지 설명한 레지스터들이 모두 개별적인 레지스터가 아니라는 것입니다. 하나의
레지스터의 값을 바꾸면 다른 세개의 레지스터의 값이 바뀝니다. EAX 레지스터를 변경하면
무조건 AL, AH와 AX 레지스터도 변경됩니다. 아주 명심하셔야 할 것입니다. 어셈블리 언어를
처음 시작하시는 분들이 자주 하시는 실수가 레지스터 값들을 깨뜨리는 것입니다.
그림 1-5에 있는 레지스터들의 관계를 완벽하게 이해하지 못하셨기 때문입니다.

The EFLAGS register is a 32-bit register that encapsulates several single-bit 
boolean (true/false) values. Most of the bits in the EFLAGs register are either
reserved for kernel mode (operating system) functions, or are of little interest 
to the application programmer. Eight of these bits (or flags) are of interest to 
application programmers writing assembly language programs. These are the overflow,
direction, interrupt disable1, sign, zero, auxiliary carry, parity, and carry flags. 
The following diagram shows their layout within the lower 16-bits of the EFLAGS register.

EFLAGS 레지스터는 여러개의 1비트 부울 (참/거짓) 값들을 가지고 있는 32비트 레지스터입니다. EFLAG 레지스터에
있는 대부분의 비트들은 커널 모드(운영체제용) 기능을 위해 사용되므로 어플리케이션
프로그래머들에게는 관련이 없습니다. 그 중에 8개의 비트(플래그라고 불림)가 어플리케이션
프로그래머들과 관련이 있습니다. 오버플로우 방향, 인터럽트 금지, 부호, 제로, 보조 캐리,
패리티, 캐리 플래그입니다. 다음 그림에는 EFLAGS 레지스터의 하위 16비트의 구조를 보여줍니다.


Figure 2.6  Layout of the FLAGS Register (Lower 16 bits of EFLAGS)

그림 2.6 FLAGS 레지스터의 구조(EFLAGS의 하위 16비트)

Of the eight flags that are usable by application programmers, four flags in particular 
are extremely valuable: the overflow, carry, sign, and zero flags. Collectively, we will 
call these four flags the condition codes2. The state of these flags (boolean variables) 
will let you test the results of previous computations and allow you to make decisions in
your programs. For example, after comparing two values, the state of the condition code 
flags will tell you if one value is less than, equal to, or greater than a second value. The 80x86 CPUs
provide special machine instructions that let you test the flags, alone or in various combinations.

8개 모두가 어플리케이션 프로그래머에게 쓸모가 있지만 오버플로우, 캐리, 부호, 제로 플래그는 꼭 알아두셔야 합니다. 우리는 잠시 뒤에 조건문을 사용할 때 이 4개의 플래그들을 사용합니다. 여러분은 이 플래그들의 상태(부울 값)를 이용하여 수행한 계산의 결과를 확인하거나 프로그램에서 필요한 선택을 할수 있게 됩니다. 2개의 변수를 비교할 때를 예로 들면, 조건에 필요한 플래그들의 상태를 이용하여 어떤 값이 다른 값보다 작거나 같거나 큰지 확인할 수 있습니다. 80x86 CPU에는 플래그 하나를 테스트하거나 여러개를 동시에 테스트할 수 있는 기계어들을 제공합니다.

The last register of interest is the EIP (instruction pointer) register. This 32-bit register 
contains the memory address of the next machine instruction to execute. Although you will 
manipulate this register directly in your programs, the instructions that modify its value 
treat this register as an implicit operand. Therefore, you will not need to remember much about 
this register since the 80x86 instruction set effectively hides it from you.

마지막으로 관심가져야 할 레지스터는 EIP(instruction pointer 명령 포인터) 레지스터입니다. 이 32비트 레지스터는 다음에 실행할 기계 명령에 대한 메모리 주소를 가지고 있습니다. 여러분이 이 레지스터를 직접 조작하고 싶으실 때도 있을겁니다. 하지만 이 레지스터의 값을 바꾸는 명령들은 이미 이 레지스터를 보이지 않게 참조하고 있습니다. 80x86 명령어들은 이 레지스터를 직접 참조하지 않고 사용할 수 있도록 처리되어있기 때문에 직접 신경쓰실 일은 없을 것입니다.

One important fact that comes as a surprise to those just learning assembly language is that 
almost all calculations on the 80x86 CPU must involve a register. For example, to add two (memory)
variables together, storing the sum into a third location, you must load one of the memory operands
into a register, add the second operand to the value in the register, and then store the register 
away in the destination memory location. Registers are a middleman in nearly every calculation. 
Therefore, registers are very important in 80x86 assembly language programs.

어셈블리 언어를 처음 접하기 시작하신 분들이 놀라시는 것 하나가 80x86 CPU가 실행하는 거의 모든 연산들이 레지스터를 필요로 한다는 것입니다. 2개의 (메모리에있는) 변수를 더해서 또 다른 장소에 저장하는 것을 예를 들면, 메모리에 있는 하나의 피연산자를 레지스터로 읽어들이고 다른 피연산자를 더해서 첫 오퍼랜드가 있는 레지스터에 저장합니다. 그 후에 최종 메모리 위치에 레지스터 값을 저장합니다. 레지스터는 거의 모든 연산에 중개인 역할을 하게됩니다. 그래서 80x86 어셈블리 언어 프로그램에서 레지스터가 아주 중요한 것입니다.

Another thing you should be aware of is that although the general purpose registers have the name "general purpose" you should not infer that you can use any register for any purpose. The SP/ESP register for example, has a very special purpose (it's the stack pointer) that effectively prevents you from using it for any other purpose. Likewise, the BP/EBP register has a special purpose that limits its usefulness as a general purpose register. All the 80x86 registers have their own special purposes that limit their use in certain contexts. For the time being, you should simply avoid the use of the ESP and EBP registers for generic calculations and keep in mind that the remaining registers are not completely interchangeable in your programs.

또 하나 알아두셔야 할 것이 있습니다. 범용 레지스터가 이름에 "범용"이 들어가지만 각 레지스터를 어떤 용도에든지 상관없이 사용할 수는 없다는 것입니다. SP/ESP레지스터를 예를 들면, 특정 용도 (스택을 가르키는 포인터)에만 사용될 수 있어서 다른 용도로는 사용하지 못하도록 막혀있습니다. 비슷하게 BP/EBP 레지스터도 정해진 용도가 있어서 범용적으로는 사용할 수 없습니다. 모든 80x86 레지스터 마다 고유한 용도가 있어서 특정 문맥에만 사용하도록 설계되어있습니다. ESP와 EBP 레지스터는 일반적인 계산에 사용하시면 안되고 나머지 다른 레지스터들도 서로 용도가 다르기 때문에 혼용해서 사용할 수 없다는 것을 명심하시기 바랍니다.

2.8  Some Basic Machine Instructions

2.8 기본적인 기계 명령어 몇가지

The 80x86 CPUs provide just over a hundred to many thousands of different machine instructions, depending on how you define a machine instruction. Even at the low end of the count (greater than 100), it appears as though there are far too many machine instructions to learn in a short period of time. Fortunately, you don't need to know all the machine instructions. In fact, most assembly language programs probably use around 30 different machine instructions3. Indeed, you can certainly write several meaningful programs with only a small handful of machine instructions. The purpose of this section is to provide a small handful of machine instructions so you can start writing simple HLA assembly language programs right away.

80x86 CPU는 수백에서 수천가지 기계 명령어를 가지고 있습니다. 최하로 잡아도 (백개는 넘겠지요) 짧은 시간내에 배우기에는 너무 많은 기계 명령어가 있어 보입니다. 다행히 모든 기계 명령어를 알아야할 필요가 없습니다. 사실 대부분의 어셈블리 언어 프로그램이 30개 내외의 명령어만을 사용하고 있습니다. 사실은 몇가지 자주 사용되는 기계 명령어만 가지고도 여러가지 유용한 프로그램을 만드실 수 있습니다. 이 섹션에서 그 자주 사용되는 몇가지의 기계 명령어를 소개하고 있으니 간단한 HLA 어셈블리 프로그램을 바로 작성하실 수 있습니다.


Without question, the MOV instruction is the most often-used assembly language statement. In a typical program, anywhere from 25-40% of the instructions are typically MOV instructions. As its name suggests, this instruction moves data from one location to another4. The HLA syntax for this instruction is

틀림없이 MOV 명령이야말로 가장 자주 사용되는 어셈블리 명령어입니다. 일반적인 프로그램에서는 전체 명령어중에 25-40%가 MOV 명령어입니다. 그 이름에서 알 수 있듯이 이 명령어는 데이터를 하나의 장소에서 다른 곳으로 옮겨주는 일을 합니다. 이 명령어의 HLA 문법은 다음과 같습니다.

mov( source_operand, destination_operand );


The source_operand can be a register, a memory variable, or a constant. The destination_operand may be a register or a memory variable. Technically the 80x86 instruction set does not allow both operands to be memory variables; HLA, however, will automatically translate a MOV instruction with two 16- or 32-bit memory operands into a pair of instructions that will copy the data from one location to another. In a high level language like Pascal or C/C++, the MOV instruction is roughly equivalent to the following assignment statement:

source_operand는 레지스터도 올 수 있고 메모리 변수나 상수도 될 수 있습니다. destination_operand는 레지스터나 메모리 변수가 됩니다. 기술적으로 80x86 명령어는 두개의 오퍼랜드가 모두 메모리 변수가 될 수 없습니다만, HLA는 자동으로 두개의 16비트나 32비트 메모리 오퍼랜드의 MOV 명령어 한개를 2개의 명령어로 분리해줍니다. 그래서 어떠한 위치의 데이터도 옮길 수 있습니다. 파스칼이나 C/C++ 등의 고급 언어와 비교해보면 MOV 명령어는 다음의 할당문과 유사합니다.


destination_operand = source_operand ;

Perhaps the major restriction on the MOV instruction's operands is that they must both be the same size. That is, you can move data between two eight-bit objects, between two 16-bit objects, or between two 32-bit objects; you may not, however, mix the sizes of the operands. The following table lists all the legal combinations:

MOV 명령어의 오퍼랜드에는 두개가 서로 같은 크기여야한다는 큰 제약사항이 있습니다. 다시 말하면 두개의 8비트 객체간의 데이터를 옮기거나 16비트 객체간에 혹은 32비트 객체간에 데이터를 옮길 수는 있지만 다른 크기의 오퍼랜드를 사용할 수는 없다는 것입니다. 다음 테이블에서 올바른 조합의 리스트를 볼 수 있습니다.

Table 1: Legal 80x86 MOV Instruction Operands
테이블 1: 올바른 80x86 MOV 명령어의 오퍼랜드 사용법

You should study this table carefully. Most of the general purpose 80x86 instructions use this same syntax. Note that in addition to the forms above, the HLA MOV instruction lets you specify two memory operands as the source and destination. However, this special translation that HLA provides only applies to the MOV instruction; it does not generalize to the other instructions.

이 테이블을 주의깊게 익히셔야 합니다. 일반적인 80x86 명령어의 대부분이 같은 문법을 사용하고 있습니다. 위의 형태들 외에 HLA의 MOV 명령어에서는 2개의 오퍼랜드 모두를 메모리 오퍼랜드로 지정할 수 있도록 지원합니다. 하지만 이렇게 변환해주는 것은 MOV 명령어 뿐입니다. 다른 명령어들도 이렇다고 생각하시면 안됩니다.

The 80x86 ADD and SUB instructions let you add and subtract two operands. Their syntax is nearly identical to the MOV instruction:

80x86의 ADD와 SUB 명령어는 두개의 오퍼랜드를 더하고 빼는 일을 합니다. MOV 명령어와 문법이 유사합니다.

add( source_operand, destination_operand );

sub( source_operand, destination_operand );

The ADD and SUB operands must take the same form as the MOV instruction, listed in the table above5. The ADD instruction does the following:

destination_operand = destination_operand + source_operand ;

destination_operand += source_operand; // For those who prefer C syntax

Similarly, the SUB instruction does the calculation:

destination_operand = destination_operand - source_operand ;

destination_operand -= source_operand ; // For C fans.

With nothing more than these three instructions, plus the HLA control structures that the next section discusses, you can actually write some sophisticated programs. Here's a sample HLA program that demonstrates these three instructions:


 
program DemoMOVaddSUB;
 

 
#include( "stdlib.hhf" );
 

 
static
 
    i8:     int8    := -8;
 
    i16:    int16   := -16;
 
    i32:    int32   := -32;
 

 
begin DemoMOVaddSUB;
 

 
    // First, print the initial values
 
    // of our variables.
 

 
    stdout.put
 
    (
 
        nl,
 
        "Initialized values: i8=", i8, 
 
        ", i16=", i16, 
 
        ", i32=", i32, 
 
        nl 
 
    );
 

 
    // Compute the absolute value of the
 
    // three different variables and
 
    // print the result.
 
    // Note, since all the numbers are
 
    // negative, we have to negate them.
 
    // Using only the MOV, ADD, and SUB
 
    // instruction, we can negate a value
 
    // by subtracting it from zero.
 

 
    mov( 0, al );   // Compute i8 := -i8;
 
    sub( i8, al );
 
    mov( al, i8 );
 
    
 
    mov( 0, ax );   // Compute i16 := -i16;
 
    sub( i16, ax );
 
    mov( ax, i16 );
 
    
 
    mov( 0, eax );  // Compute i32 := -i32;
 
    sub( i32, eax );
 
    mov( eax, i32 );
 

 
    // Display the absolute values:
 

 
    stdout.put
 
    ( 
 
        nl,
 
        "After negation: i8=", i8, 
 
        ", i16=", i16, 
 
        ", i32=", i32, 
 
        nl 
 
    );
 

 
    // Demonstrate ADD and constant-to-memory
 
    // operations:
 

 
    add( 32323200, i32 );
 
    stdout.put( nl, "After ADD: i32=", i32, nl );
 

 

 
    
 
end DemoMOVaddSUB;
 

 
Program 2.3  Demonstration of MOV, ADD, and SUB Instructions
 











